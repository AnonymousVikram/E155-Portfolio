[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home",
    "section": "",
    "text": "Vikram Krishna is a student at Harvey Mudd College studying Engineering and Computer Science. He has had extensive experience designing performant systems, machine learning models, and low-latency algorithms. He is also a Clay-Wolkin Fellow, where he helps design and improve an open source RISC-V Processor. His personal interests include going hiking, watching Formula 1, and playing video games."
  },
  {
    "objectID": "index.html#education",
    "href": "index.html#education",
    "title": "Home",
    "section": "Education",
    "text": "Education\n\n\n\n\n\n\n\nHarvey Mudd CollegeB.S. in Engineering and Computer Science\nClaremont, CAAug 2022 - May 2026"
  },
  {
    "objectID": "index.html#experience",
    "href": "index.html#experience",
    "title": "Home",
    "section": "Experience",
    "text": "Experience\n\n\n\nHarvey Mudd College | Clay-Wolkin Fellow\nMay 2024 - Present\n\n\nBloomberg LP | Software Engineer\nJune 2024 - Aug 2024\n\n\nAirGuard Industries | Data Scientist\nJune 2021 - May 2024"
  },
  {
    "objectID": "posts/initial-reflections.html",
    "href": "posts/initial-reflections.html",
    "title": "Pre-Course Reflection",
    "section": "",
    "text": "Coming into Mudd, I was dead set on pursuing robotics. I always enjoyed it in High School and thought that’s what I wanted to do for the rest of my life. I even set up my own major in Engineering and Computer Science to help facilitate this and enable me to take more relevant courses.\nHowever, all of this changed when I took E85 — Digital Electronics and Computer Architecture. Something about the logic paths and thinking about the microarchitecture really spoke to me. Since then, I have been selected as a Clay-Wolking fellow, and want to further pursue my newfound interest in this field.\nWith this in mind, I have a couple of primary goals that I want to achieve to think of my time in E155 as successful:\n\nBecome a lot more comfortable writing SystemVerilog, keeping in mind it’s meant for synthesis of hardware\nBuild my ability to plan out and reason through datapaths\nLearn new communication protocols and other specifics of microarchitecture\nCreate a cool final project!\n\nAs with all things, I believe that the best way to learn and improve my skills is by applying it, and I can’t wait to do that within this course!"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Pre-Course Reflection\n\n\n\n\n\nLooking at what I want to achieve from this course\n\n\n\n\n\nSep 4, 2024\n\n\nVikram Krishna\n\n\n\n\n\n\n\n\n\n\n\n\nHello Quarto\n\n\n\n\n\nWelcome to my Quarto portfolio\n\n\n\n\n\nAug 28, 2024\n\n\nVikram Krishna\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1",
    "section": "",
    "text": "Per the guidelines provided, the main goals of this lab were to:\n\nAssemble the E155 Dev Board\nWrite a SystemVerilog Module to control a seven segment display and execute LED logic\nProgram an FPGA with the Module created\nGain confidence in building, assembling, testing, and debugging circuits\nInterface a seven segment display to the board\n\nWith this in mind, my first task was to solder the dev board. Although I’ve had a lot of experience with through-hole soldering, there were quite a few surface mount components that had to be soldered. This posed itself to be quite the tall task, and I certainly made mistakes. These mistakes were only discovered, though, through testing and debugging. I realized there were a couple of cold joints, as well as some diodes placed in the wrong orientation.\nAfter soldering, I managed to write the SystemVerilog module, flash it, and run it successfully and my new board!"
  },
  {
    "objectID": "labs/lab1/lab1.html#overview",
    "href": "labs/lab1/lab1.html#overview",
    "title": "Lab 1",
    "section": "",
    "text": "Per the guidelines provided, the main goals of this lab were to:\n\nAssemble the E155 Dev Board\nWrite a SystemVerilog Module to control a seven segment display and execute LED logic\nProgram an FPGA with the Module created\nGain confidence in building, assembling, testing, and debugging circuits\nInterface a seven segment display to the board\n\nWith this in mind, my first task was to solder the dev board. Although I’ve had a lot of experience with through-hole soldering, there were quite a few surface mount components that had to be soldered. This posed itself to be quite the tall task, and I certainly made mistakes. These mistakes were only discovered, though, through testing and debugging. I realized there were a couple of cold joints, as well as some diodes placed in the wrong orientation.\nAfter soldering, I managed to write the SystemVerilog module, flash it, and run it successfully and my new board!"
  },
  {
    "objectID": "labs/lab1/lab1.html#design",
    "href": "labs/lab1/lab1.html#design",
    "title": "Lab 1",
    "section": "Design",
    "text": "Design\nFor the SystemVerilog module, I realized there were two main devices I was controlling with the switches: three LEDs, and one 7-segment display. As a result, I split the code into three modules, one for each device and one top module. To program the 7-segment display, I used an always_comb block, resulting in the display changing output as soon as any of the switches are changed. On the other hand, the LEDs required some additional manipulation. I noticed that led[0] and led[1] could be simplified to combinational logic using a XOR and AND gate respectively, so I designed that using an assign statement. However, for led[3], since it was required to blink at 2.4Hz, given an oscillator-generated clock of 48MHz, I required an always_ff block used in conjunction with a counter and an internal logic variable to keep track of whether the light should be on or off. This explanation can be visualized using the diagram below:\n\nAs for the circuit, particular care had to be taken in the connection of the 7-segment display. To begin with, I realized that each segment needed to have its own resistor, rather than having a shared resistor when connecting the anode. This is due to Kirchoff’s Junction Law, which tells us that the current going into a junction will be equal to the current leaving the junction. Since there would be a standard amount of current from the anode, if there was a common resistor, it would result in differences in the brightness of segments, if only one segment was illuminated, as opposed to all seven being lit up. This consideration resulted in the following circuit diagram:\n\nThen, to determine the value of each resistor, we can do some math, while taking into account that by Kirchoff’s Junction law, each branch receives the 3.3V, and that from the datasheet, the forward voltage across a segment is 2.1V. From the datasheet, we can also determine that the ideal current should be 20mA.\n\\[\nV = IR\n\\]\n\\[\nR_1 = \\frac{3.3-2.1}{0.02}=60\\Omega\n\\]\nThus, with this calculation, we know that each of the resistors in the circuit should be \\(60 \\Omega\\) ."
  },
  {
    "objectID": "labs/lab1/lab1.html#testing",
    "href": "labs/lab1/lab1.html#testing",
    "title": "Lab 1",
    "section": "Testing",
    "text": "Testing\nThe testing for this lab was quite straightforward, given the only inputs were four switches, resulting in 16 possible combinations. In order to test, I wrote a testbench with all possible inputs simulated, and verified against the output. The test results are below:\n\nWaveform\n\n\n\nResult"
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "Lab 1",
    "section": "Conclusion",
    "text": "Conclusion\nMy design was successful in meeting all the requirements for this lab. I also believe I succeeded in meeting the goals of the overall lab. I spent 7 hours working on this lab."
  },
  {
    "objectID": "labs/lab_overview.html",
    "href": "labs/lab_overview.html",
    "title": "Labs Overview",
    "section": "",
    "text": "The Microprocessor Systems class at Harvey Mudd employs a lab-based approach to testing absorption of material. As a result of this, there are seven labs covering a wide variety of topics, each of which has clear guidelines and a report. Below, links can be found to the original task and the corresponding write-up for my submission."
  },
  {
    "objectID": "labs/lab_overview.html#background",
    "href": "labs/lab_overview.html#background",
    "title": "Labs Overview",
    "section": "",
    "text": "The Microprocessor Systems class at Harvey Mudd employs a lab-based approach to testing absorption of material. As a result of this, there are seven labs covering a wide variety of topics, each of which has clear guidelines and a report. Below, links can be found to the original task and the corresponding write-up for my submission."
  },
  {
    "objectID": "labs/lab_overview.html#labs",
    "href": "labs/lab_overview.html#labs",
    "title": "Labs Overview",
    "section": "Labs",
    "text": "Labs\n\n\n\nLab Number\nInstructions\nReport\nGithub Repo\n\n\n\n\n1: FPGA and MCU Setup and Testing\nLab 1 Instructions\nLab 1 Report\nLab 1 Repo"
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2",
    "section": "",
    "text": "Per the guidelines provided, the main goals of this lab were to:\n\nLearn about and implement time multiplexing to drive two seven-segment displays\nUse transistors to provide greater current to drive the displays using FPGA GPIO Pins"
  },
  {
    "objectID": "labs/lab2/lab2.html#overview",
    "href": "labs/lab2/lab2.html#overview",
    "title": "Lab 2",
    "section": "",
    "text": "Per the guidelines provided, the main goals of this lab were to:\n\nLearn about and implement time multiplexing to drive two seven-segment displays\nUse transistors to provide greater current to drive the displays using FPGA GPIO Pins"
  },
  {
    "objectID": "labs/lab2/lab2.html#design",
    "href": "labs/lab2/lab2.html#design",
    "title": "Lab 2",
    "section": "Design",
    "text": "Design\nFor the SystemVerilog module, I realized there were two main devices I was controlling with the switches: three LEDs, and one 7-segment display. As a result, I split the code into three modules, one for each device and one top module. To program the 7-segment display, I used an always_comb block, resulting in the display changing output as soon as any of the switches are changed. On the other hand, the LEDs required some additional manipulation. I noticed that led[0] and led[1] could be simplified to combinational logic using a XOR and AND gate respectively, so I designed that using an assign statement. However, for led[3], since it was required to blink at 2.4Hz, given an oscillator-generated clock of 48MHz, I required an always_ff block used in conjunction with a counter and an internal logic variable to keep track of whether the light should be on or off. This explanation can be visualized using the diagram below:\n\nAs for the circuit, particular care had to be taken in the connection of the 7-segment display. To begin with, I realized that each segment needed to have its own resistor, rather than having a shared resistor when connecting the anode. This is due to Kirchoff’s Junction Law, which tells us that the current going into a junction will be equal to the current leaving the junction. Since there would be a standard amount of current from the anode, if there was a common resistor, it would result in differences in the brightness of segments, if only one segment was illuminated, as opposed to all seven being lit up. This consideration resulted in the following circuit diagram:\n\nThen, to determine the value of each resistor, we can do some math, while taking into account that by Kirchoff’s Junction law, each branch receives the 3.3V, and that from the datasheet, the forward voltage across a segment is 2.1V. From the datasheet, we can also determine that the ideal current should be 20mA.\n\\[\nV = IR\n\\]\n\\[\nR = \\frac{3.3-2.1}{0.02}=60\\Omega\n\\]\nThus, with this calculation, we know that each of the resistors in the circuit should be \\(60 \\Omega\\) ."
  },
  {
    "objectID": "labs/lab2/lab2.html#testing",
    "href": "labs/lab2/lab2.html#testing",
    "title": "Lab 2",
    "section": "Testing",
    "text": "Testing\nThe testing for this lab was quite straightforward, given the only inputs were four switches, resulting in 16 possible combinations. In order to test, I wrote a testbench with all possible inputs simulated, and verified against the output. The test results are below:\n\nWaveform\n\n\n\nResult"
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "Lab 2",
    "section": "Conclusion",
    "text": "Conclusion\nMy design was successful in meeting all the requirements for this lab. I also believe I succeeded in meeting the goals of the overall lab. I spent 7 hours working on this lab."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Hello Quarto",
    "section": "",
    "text": "Hello World!"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "Course Website:  Link"
  }
]